define endian=little;
define alignment=1;

define space rom          type=ram_space       size=2  wordsize=1  default;
define space ram          type=ram_space       size=2  wordsize=1;
define space register     type=register_space  size=2  wordsize=1;

define register offset=0x00 size=1 [R0 R1 R2 R3 R4 R5 R6 R7];
define register offset=0x00 size=2 [ER0 ER1 ER2 ER3];
define register offset=0x08 size=1 [SSPL SSPH LRBL LRBH PSWL PSWH AL AH];
define register offset=0x08 size=2 [SSP LRB PSW ACC PC X1 X2 DP USP];
define register offset=0x20 size=1 [CSR TSR DSR ROMWIN];
define register offset=0x30 size=4 [contextreg];
# taking a cue from x86, define pseudo-registers for each flag separately,
# otherwise decompilation is a mess
define register offset=0x40 size=1 [C Z S OV];

macro packflags(psw) {
  psw = (0x8000 * zext(C&1))
      | (0x4000 * zext(Z&1))
      | (0x0800 * zext(S&1))
      | (0x0200 * zext(OV&1))
      | (0x35ff & psw);
}

# contextreg is a hack to copy the DD flag out of PSW (which is located in RAM 0x04)
define context contextreg
  dd=(0,0);

define token instr(8)
	op = (0, 7)
	bitop0 = (3, 7)
	bit = (0, 2) dec
	regop0 = (3, 7)
	reg8 = (0, 2)
	reg16 = (0, 2)
	hregop0 = (2, 7)
	ERn = (0, 1)
	PRn = (0, 1)
	widthbits = (0, 1)
	Rn = (0, 2)
    caddr11h0 = (0, 1)
    caddr11h1 = (2, 3)
    caddr11h2 = (4, 4)
    caddr11h3 = (5, 7)
    sba6 = (0, 5)
    sbaop = (6, 7)
;

define token preofftok(8)
    preoff = (0, 7)
	preregop0 = (3, 7)
	prereg8 = (0, 2)
	prereg16 = (0, 2)
;

define token sufofftok(8)
    n8 = (0, 7)
    rdiff8 = (0, 7) signed
    r45switch = (7, 7)
    rdiff7 = (0, 6) signed
;

attach variables [ reg8 prereg8 Rn ] [ R0 R1 R2 R3 R4 R5 R6 R7 ];
attach variables [ reg16 prereg16 ] [ X1 X2 DP USP ER0 ER1 ER2 ER3 ];
attach variables [ PRn ] [ X1 X2 DP USP ];
attach variables [ ERn ] [ ER0 ER1 ER2 ER3 ];
attach variables [ r45switch ] [ R4 R5 ];

define token imm16token(16) n16 = (0, 15) op1n16 = (0, 15);

rel8: relAddr is rdiff8 [ relAddr = inst_next+rdiff8; ] { export *[rom]:1 relAddr; }

fix8: "fix" fixaddr is n8 [ fixaddr = 0x200 + n8; ] { export *[ram]:1 fixaddr; }
off8: "off" offaddr is n8 [ offaddr = (LRB & 0xff00) + n8; ] { export *[ram]:1 offaddr; }
sfr8: SSPL is n8 = 0x00 & SSPL { export SSPL; }
sfr8: SSPH is n8 = 0x01 & SSPH { export SSPH; }
sfr8: LRBL is n8 = 0x02 & LRBL { export LRBL; }
sfr8: LRBH is n8 = 0x03 & LRBH { export LRBH; }
sfr8: PSWL is n8 = 0x04 & PSWL { packflags(PSW); export PSWL; }
sfr8: PSWH is n8 = 0x05 & PSWH { packflags(PSW); export PSWH; }
sfr8: AL   is n8 = 0x06 & AL   { export AL; }
sfr8: AH   is n8 = 0x07 & AH   { export AH; }
sfr8: n8   is n8               { export *[ram]:1 n8; }

op1n16b: op1n16 is op1n16 { export *[ram]:1 op1n16; }
op1n16w: op1n16 is op1n16 { export *[ram]:2 op1n16; }

fix16: "fix" fixaddr is n8 [ fixaddr = 0x200 + n8; ] { export *[ram]:2 fixaddr; }
off16: "off" offaddr is n8 [ offaddr = (LRB & 0xff00) + n8; ] { export *[ram]:2 offaddr; }
sfr16: SSP is n8 = 0x00 & SSP { export SSP; }
sfr16: LRB is n8 = 0x02 & LRB { export LRB; }
sfr16: PSW is n8 = 0x04 & PSW { packflags(PSW); export PSW; }
sfr16: ACC is n8 = 0x06 & ACC { export ACC; }
sfr16: n8  is n8              { export *[ram]:2 n8; }

op1fix8: fix8 is fix8 { export fix8; }
op1sfr8: sfr8 is sfr8 { export sfr8; }
op1off8: off8 is off8 { export off8; }
op1fix16: fix16 is fix16 { export fix16; }
op1sfr16: sfr16 is sfr16 { export sfr16; }
op1off16: off16 is off16 { export off16; }

A8: AL is epsilon & AL { export AL; }
A16: ACC is epsilon & ACC { export ACC; }
A16indb: [ACC] is epsilon & ACC { export *[ram]:1 ACC; }
A16indw: [ACC] is epsilon & ACC { export *[ram]:2 ACC; }
A_8: AL is epsilon & AL { export AL; }
A_16: ACC is epsilon & ACC { export ACC; } 

DPindw: [DP] is epsilon & DP { export *[ram]:2 DP; }
DPindincw: [DP+] is epsilon & DP { local a = *[ram]:2 DP; DP = DP+1; export a; }
DPinddecw: [DP-] is epsilon & DP { local a = *[ram]:2 DP; DP = DP-1; export a; }
DPindb: [DP] is epsilon & DP { export *[ram]:1 DP; }
DPindincb: [DP+] is epsilon & DP { local a = *[ram]:1 DP; DP = DP+1; export a; }
DPinddecb: [DP-] is epsilon & DP { local a = *[ram]:1 DP; DP = DP-1; export a; }

X1indw: [X1] is epsilon & X1 { export *[ram]:2 X1; }
X1indb: [X1] is epsilon & X1 { export *[ram]:1 X1; }
X1immw: op1n16[X1] is op1n16 & X1 { local a = X1+op1n16; export *[ram]:2 a; }
X1immb: op1n16[X1] is op1n16 & X1 { local a = X1+op1n16; export *[ram]:1 a; }
X1plusAw: [X1+AL] is epsilon & X1 & AL { local a = X1+zext(AL); export *[ram]:2 a; }
X1plusAb: [X1+AL] is epsilon & X1 & AL { local a = X1+zext(AL); export *[ram]:1 a; }
X1plusR0w: [X1+R0] is epsilon & X1 & R0 { local a = X1+zext(R0); export *[ram]:2 a; }
X1plusR0b: [X1+R0] is epsilon & X1 & R0 { local a = X1+zext(R0); export *[ram]:1 a; }

X2immw: op1n16[X2] is op1n16 & X2 { local a = X2+op1n16; export *[ram]:2 a; }
X2immb: op1n16[X2] is op1n16 & X2 { local a = X2+op1n16; export *[ram]:1 a; }

# second copy because these can appear in both operands
X1indw2: [X1] is epsilon & X1 { export *[ram]:2 X1; }
X1indb2: [X1] is epsilon & X1 { export *[ram]:1 X1; }
DPindw2: [DP] is epsilon & DP { export *[ram]:2 DP; }
DPindincw2: [DP+] is epsilon & DP { local a = *[ram]:2 DP; DP = DP+1; export a; }
DPinddecw2: [DP-] is epsilon & DP { local a = *[ram]:2 DP; DP = DP-1; export a; }
DPindb2: [DP] is epsilon & DP { export *[ram]:1 DP; }
DPindincb2: [DP+] is epsilon & DP { local a = *[ram]:1 DP; DP = DP+1; export a; }
DPinddecb2: [DP-] is epsilon & DP { local a = *[ram]:1 DP; DP = DP-1; export a; }
X1plusAw2: [X1+AL] is epsilon & X1 & AL { local a = X1+zext(AL); export *[ram]:2 a; }
X1plusAb2: [X1+AL] is epsilon & X1 & AL { local a = X1+zext(AL); export *[ram]:1 a; }
X1plusR0w2: [X1+R0] is epsilon & X1 & R0 { local a = X1+zext(R0); export *[ram]:2 a; }
X1plusR0b2: [X1+R0] is epsilon & X1 & R0 { local a = X1+zext(R0); export *[ram]:1 a; }

sbafix: "sbafix" sbaddr is sba6 [ sbaddr = sba6 + 0x2C0; ] { export *[ram]:1 sbaddr; }
sbaoff: "sbaoff" sbaddr is sba6 [ sbaddr = sba6 + 0x0C0 + (LRBH & 0xff00); ] { export *[ram]:1 sbaddr; }

width: width is widthbits [ width = widthbits+1; ] { export width; }

macro push(obj) {
  SSP = SSP-2;
  *[ram]:2 SSP = obj;
}

macro pop(obj) {
  obj = *[ram]:2 SSP;
  SSP = SSP+2;
}

@include "nx8-500s.sinc"

# implement ACAL here as it's a special case

ACALaddr11: caddr11 is caddr11h0 & caddr11h2 & caddr11h1 = 1 & caddr11h3 = 2; n8
  [caddr11 = 0x1000 + (caddr11h0 << 8) + (caddr11h2 << 10) + n8;]
  { export *[rom]:1 caddr11; }

:ACAL ACALaddr11 is ACALaddr11 { push(&:2 inst_next); call ACALaddr11; }